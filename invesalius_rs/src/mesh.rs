use core::{f64, hash};
use crossbeam_deque::{Injector, Steal, Stealer, Worker};
use nalgebra::{Point3, Vector3};
use ndarray::parallel::prelude::*;
use ndarray::{Array, Array1, Dim};
use ndarray::{Array2, ArrayView2, ArrayViewMut2};
use num_traits::{AsPrimitive, NumCast};
use numpy::ndarray;
use pyo3::prelude::*;
use rayon::Scope;
use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicI64, AtomicU64, Ordering};
use std::sync::Arc;
use std::sync::Mutex;

use crate::types::{FaceArray, VertexArray};

pub trait Vertex:
    num_traits::Float + Copy + Send + Sync + NumCast + std::ops::AddAssign<Self> + AsPrimitive<f64>
{
}

impl Vertex for f32 {}
impl Vertex for f64 {}

pub trait Face:
    num_traits::PrimInt + Copy + Send + Sync + Ord + hash::Hash + AsPrimitive<usize>
{
}

impl Face for i32 {}
impl Face for i64 {}
impl Face for u32 {}
impl Face for u64 {}

pub fn context_aware_smoothing_internal<V, F, N>(
    vertices: ArrayViewMut2<V>,
    faces: ArrayViewMut2<F>,
    normals: ArrayViewMut2<N>,
    t: f64,
    tmax: f64,
    bmin: f64,
    n_iters: u32,
) where
    V: Vertex,
    F: Face,
    N: Vertex,
{
    let t0 = std::time::Instant::now();
    let map_vface = build_map_vface(&faces.view());
    let t1 = std::time::Instant::now();
    println!("build_map_vface time: {:?}", t1.duration_since(t0));
    let t0 = std::time::Instant::now();
    let vertex_connectivity = build_vertex_connectivity(&faces.view(), &vertices.view());
    let t1 = std::time::Instant::now();
    println!("build_vertex_connectivity time: {:?}", t1.duration_since(t0));
    let _edge_nfaces: HashMap<(F, F), i32> = HashMap::new();
    let _border_vertices: HashSet<F> = HashSet::new();

    let stack_orientation = [0.0, 0.0, 1.0];
    let t0 = std::time::Instant::now();
    let vertices_staircase = find_staircase_artifacts(
        &vertices.view(),
        &faces.view(),
        &normals.view(),
        &map_vface,
        stack_orientation,
        t,
    );
    let t1 = std::time::Instant::now();
    println!("find_staircase_artifacts time: {:?}", t1.duration_since(t0));
    // let weights = calc_artifacts_weight(
    //     &vertices.view(),
    //     &faces.view(),
    //     &normals.view(),
    //     &map_vface,
    //     &vertices_staircase,
    //     tmax,
    //     bmin,
    // );
    let t0 = std::time::Instant::now();
    let weights = floodfill_mesh(
        &vertices.view(),
        &faces.view(),
        &vertex_connectivity,
        &vertices_staircase,
        tmax,
        bmin,
    );
    let t1 = std::time::Instant::now();
    println!("floodfill_mesh time: {:?}", t1.duration_since(t0));
    let t0 = std::time::Instant::now();
    taubin_smooth(
        vertices,
        &vertex_connectivity,
        &weights,
        0.5,
        -0.53,
        n_iters,
    );
    let t1 = std::time::Instant::now();
    println!("taubin_smooth time: {:?}", t1.duration_since(t0));
}

fn build_map_vface<F>(faces: &ArrayView2<F>) -> HashMap<usize, Vec<usize>>
where
    F: Face,
{
    let mut map_vface: HashMap<usize, Vec<usize>> = HashMap::with_capacity(faces.nrows());

    for (f_id, face) in faces.outer_iter().enumerate() {
        for &v_id in face.iter() {
            map_vface.entry(v_id.as_()).or_default().push(f_id);
        }
    }
    map_vface
}

fn build_vertex_connectivity<F, V>(faces: &ArrayView2<F>, vertices: &ArrayView2<V>) -> HashMap<usize, Vec<usize>>
where
    F: Face,
    V: Vertex,
{
    let mut vertex_connectivity: HashMap<usize, Vec<usize>> = HashMap::with_capacity(vertices.nrows());

    for (f_id, face) in faces.outer_iter().enumerate() {
        for &v_i in face.iter().skip(1) {
            for &v_j in face.iter().skip(1) {
                if v_i != v_j {
                    vertex_connectivity
                        .entry(v_i.as_())
                        .or_default()
                        .push(v_j.as_());
                }
            }
        }
    }
    vertex_connectivity
}

pub fn find_staircase_artifacts<V, F, N>(
    vertices: &ArrayView2<V>,
    _faces: &ArrayView2<F>,
    normals: &ArrayView2<N>,
    map_vface: &HashMap<usize, Vec<usize>>,
    stack_orientation: [f64; 3],
    t: f64,
) -> Vec<usize>
where
    V: Vertex,
    F: Face,
    N: Vertex,
{
    let n_vertices = vertices.shape()[0];
    let stack_orientation = Vector3::from_row_slice(&stack_orientation);

    let output = (0..n_vertices)
        .into_par_iter()
        .filter_map(|v_id: usize| {
            let mut max_z = f64::MIN;
            let mut min_z = f64::MAX;
            let mut max_y = f64::MIN;
            let mut min_y = f64::MAX;
            let mut max_x = f64::MIN;
            let mut min_x = f64::MAX;

            if let Some(f_ids) = map_vface.get(&v_id) {
                for &f_id in f_ids {
                    let normal = normals.row(f_id);
                    let normal_vec =
                        Vector3::new(normal[0].as_(), normal[1].as_(), normal[2].as_());

                    let of_z = 1.0 - (normal_vec.dot(&stack_orientation)).abs();
                    let of_y = 1.0 - (normal_vec.dot(&Vector3::new(0.0, 1.0, 0.0))).abs();
                    let of_x = 1.0 - (normal_vec.dot(&Vector3::new(1.0, 0.0, 0.0))).abs();

                    if of_z > max_z {
                        max_z = of_z;
                    }
                    if of_z < min_z {
                        min_z = of_z;
                    }
                    if of_y > max_y {
                        max_y = of_y;
                    }
                    if of_y < min_y {
                        min_y = of_y;
                    }
                    if of_x > max_x {
                        max_x = of_x;
                    }
                    if of_x < min_x {
                        min_x = of_x;
                    }

                    if (max_z - min_z).abs() >= t
                        || (max_y - min_y).abs() >= t
                        || (max_x - min_x).abs() >= t
                    {
                        return Some(v_id);
                    }
                }
            }
            None
        })
        .collect::<Vec<usize>>();
    output
}

fn calc_artifacts_weight<V, F, N>(
    vertices: &ArrayView2<V>,
    faces: &ArrayView2<F>,
    _normals: &ArrayView2<N>,
    map_vface: &HashMap<usize, Vec<usize>>,
    vertices_staircase: &[usize],
    tmax: f64,
    bmin: f64,
) -> Vec<f64>
where
    V: Vertex,
    F: Face,
    N: Vertex,
{
    let n_vertices = vertices.shape()[0];
    let weights = Mutex::new(vec![bmin; n_vertices]);

    vertices_staircase.into_par_iter().for_each(|vi_id| {
        {
            let mut weights = weights.lock().unwrap();
            weights[*vi_id] = 1.0;
        }

        let near_vertices = get_near_vertices_to_v(vertices, faces, map_vface, *vi_id, tmax);
        let vi = vertices.row(*vi_id);
        let p_vi = Point3::new(vi[0].as_(), vi[1].as_(), vi[2].as_());

        for &vj_id in &near_vertices {
            let vj = vertices.row(vj_id);
            let p_vj = Point3::new(vj[0].as_(), vj[1].as_(), vj[2].as_());
            let d = (p_vi - p_vj).norm();
            let value = (1.0 - d / tmax) * (1.0 - bmin) + bmin;

            {
                let mut weights = weights.lock().unwrap();
                if value > weights[vj_id] {
                    weights[vj_id] = value;
                }
            }
        }
    });

    weights.into_inner().unwrap()
}

pub fn floodfill_mesh<V, F>(
    vertices: &ArrayView2<V>,
    faces: &ArrayView2<F>,
    vertex_connectivity: &HashMap<usize, Vec<usize>>,
    vertices_staircase: &Vec<usize>,
    tmax: f64,
    bmin: f64,
) -> Array1<f64>
where
    V: Vertex,
    F: Face,
{
    let mut visited = Arc::new(
        (0..vertices.shape()[0])
            .map(|_| AtomicBool::new(false))
            .collect::<Vec<_>>(),
    );
    let mut injector = Arc::new(Injector::new());
    let mut map_vstaircase = Arc::new((0..vertices.shape()[0]).map(|_| AtomicI64::new(-1)).collect::<Vec<_>>());
    let mut weights = Array1::from_elem(vertices.shape()[0], bmin);

    for &v_id in vertices_staircase.iter() {
        if !visited[v_id].swap(true, Ordering::AcqRel) {
            injector.push((v_id));
            map_vstaircase[v_id].store(v_id as i64, Ordering::Release);
        }
    }
    rayon::scope(|scope| {
        let n_threads = rayon::current_num_threads();
        let workers: Vec<_> = (0..n_threads).map(|_| Worker::new_fifo()).collect();

        let stealers: Vec<Stealer<usize>> = workers.iter().map(|w| w.stealer()).collect();
        for worker in workers {
            let visited = visited.clone();
            let injector = injector.clone();
            let stealers = stealers.clone();
            let map_vstaircase = map_vstaircase.clone();
            scope.spawn(move |_| {
                loop {
                    let v = worker.pop()
                        .or_else(|| match injector.steal_batch_and_pop(&worker) {
                            Steal::Success(x) => Some(x),
                            _ => None,
                        })
                        .or_else(|| {
                            stealers.iter().find_map(|s| match s.steal() {
                                Steal::Success(x) => Some(x),
                                _ => None,
                            })
                        });
                        let v = match v {
                            Some(x) => x,
                            None => break,
                        };

                        for &vj in vertex_connectivity.get(&v).unwrap_or(&vec![]) {
                            let pi = Vector3::new(vertices.row(v)[0].as_(), vertices.row(v)[1].as_(), vertices.row(v)[2].as_());
                            let pj = Vector3::new(vertices.row(vj)[0].as_(), vertices.row(vj)[1].as_(), vertices.row(vj)[2].as_());
                            let dist_sq = (pi - pj).norm_squared();
                            if dist_sq > tmax * tmax {
                                continue;
                            }
                            let value = (1.0 - dist_sq / tmax) * (1.0 - bmin) + bmin;
                            let old_value = map_vstaircase[vj].load(Ordering::Acquire);
                            if old_value > -1 {
                                let old_pi = Vector3::new(vertices.row(old_value as usize)[0].as_(), vertices.row(old_value as usize)[1].as_(), vertices.row(old_value as usize)[2].as_());
                                let old_distance = (pi - old_pi).norm_squared();
                                if dist_sq > old_distance {
                                    continue;
                                }
                            }
                            map_vstaircase[vj].store(map_vstaircase[v].load(Ordering::Acquire), Ordering::Release);
                            if !visited[vj].swap(true, Ordering::AcqRel) {
                                injector.push((vj));
                        }
                }
            }
            });
        }

    });
    for v_id in 0..vertices.shape()[0] {
        let value = map_vstaircase[v_id].load(Ordering::Acquire);
        if value > -1 {
            let pi = Vector3::new(vertices.row(v_id)[0].as_(), vertices.row(v_id)[1].as_(), vertices.row(v_id)[2].as_());
            let pj = Vector3::new(vertices.row(value as usize)[0].as_(), vertices.row(value as usize)[1].as_(), vertices.row(value as usize)[2].as_());
            let d = (pi - pj).norm();
            let value = (1.0 - d / tmax) * (1.0 - bmin) + bmin;
            weights[v_id] = weights[v_id].max(value);
        }
    }
    weights
}

#[inline]
fn calc_d<V>(
    vertices: &ArrayView2<V>,
    vertex_connectivity: &HashMap<usize, Vec<usize>>,
    v_id: usize,
) -> Vector3<f64>
where
    V: Vertex,
{
    let vi = vertices.row(v_id);
    let p_vi = Vector3::new(vi[0].as_(), vi[1].as_(), vi[2].as_());

    let mut d = Vector3::zeros();
    let mut n = 0usize;

    if is_border(v_id) {
        for &vj_id in vertex_connectivity.get(&v_id).unwrap_or(&vec![]) {
            if is_border(vj_id) {
                let vj = vertices.row(vj_id);
                let p_vj = Vector3::new(vj[0].as_(), vj[1].as_(), vj[2].as_());
                d += p_vi - p_vj;
                n += 1;
            }
        }
    } else {
        for &vj_id in vertex_connectivity.get(&v_id).unwrap_or(&vec![]).iter() {
            let vj = vertices.row(vj_id);
            let p_vj = Vector3::new(vj[0].as_(), vj[1].as_(), vj[2].as_());
            d += p_vi - p_vj;
            n += 1;
        }
    }

    if n > 0 {
        d / n as f64
    } else {
        d
    }
}

fn is_border(_v_id: usize) -> bool {
    // Convert v_id to F type for lookup
    // Since we're using ArrayView, we need to check if the vertex index exists in border_vertices
    // For now, we'll need to convert: but border_vertices stores F, not usize
    // This is a design issue - border_vertices should probably be HashSet<usize>
    // For now, we'll check by converting back
    false // TODO: Fix this - border_vertices type mismatch
}

fn get_ring1<F>(
    faces: &ArrayView2<F>,
    map_vface: &HashMap<usize, Vec<usize>>,
    v_id: usize,
) -> HashSet<usize>
where
    F: Face,
{
    let mut ring1 = HashSet::new();
    if let Some(f_ids) = map_vface.get(&v_id) {
        for &f_id in f_ids {
            let face = faces.row(f_id);
            for i in 1..4 {
                let v = face[i].as_();
                if v != v_id {
                    ring1.insert(v);
                }
            }
        }
    }
    ring1
}

fn get_near_vertices_to_v<V, F>(
    vertices: &ArrayView2<V>,
    faces: &ArrayView2<F>,
    map_vface: &HashMap<usize, Vec<usize>>,
    v_id: usize,
    dmax: f64,
) -> Vec<usize>
where
    V: Vertex,
    F: Face,
{
    let mut near_vertices = Vec::new();
    let mut to_visit = VecDeque::new();
    let mut status_v = HashSet::new();

    let v_i = vertices.row(v_id);
    let p_i = Point3::new(v_i[0].as_(), v_i[1].as_(), v_i[2].as_());

    to_visit.push_back(v_id);
    status_v.insert(v_id);

    let dmax_sq = dmax * dmax;

    while let Some(current_v_id) = to_visit.pop_front() {
        if let Some(f_ids) = map_vface.get(&current_v_id) {
            for &f_id in f_ids {
                let face = faces.row(f_id);
                for i in 1..4 {
                    let v_j_id = face[i].as_();
                    if !status_v.contains(&v_j_id) {
                        status_v.insert(v_j_id);
                        let v_j = vertices.row(v_j_id);
                        let p_j = Point3::new(v_j[0].as_(), v_j[1].as_(), v_j[2].as_());
                        let dist_sq = (p_i - p_j).norm_squared();
                        if dist_sq <= dmax_sq {
                            near_vertices.push(v_j_id);
                            to_visit.push_back(v_j_id);
                        }
                    }
                }
            }
        }
    }
    near_vertices
}

fn taubin_smooth<V>(
    mut vertices: ArrayViewMut2<V>,
    vertex_connectivity: &HashMap<usize, Vec<usize>>,
    weights: &Array1<f64>,
    l: f64,
    m: f64,
    steps: u32,
) where
    V: Vertex,
{
    let n_vertices = vertices.shape()[0];
    let mut d_values: Array2<f64> = Array2::zeros((n_vertices, 3));

    for _ in 0..steps {
        // Calculate D for all vertices

        par_azip!((index i, mut d in d_values.outer_iter_mut()) {
            let d_vec = calc_d(&vertices.view(), &vertex_connectivity, i);
            d[0] = d_vec.x;
            d[1] = d_vec.y;
            d[2] = d_vec.z;
        });

        // Apply first smoothing step (lambda)
        par_azip!((index i, mut vertex in vertices.outer_iter_mut(), d in d_values.outer_iter()) {
            let dx: V = NumCast::from(weights[i] * l * d[0]).unwrap_or(vertex[0]);
            let dy: V = NumCast::from(weights[i] * l * d[1]).unwrap_or(vertex[1]);
            let dz: V = NumCast::from(weights[i] * l * d[2]).unwrap_or(vertex[2]);
            vertex[[0]] += dx;
            vertex[[1]] += dy;
            vertex[[2]] += dz;
        });

        par_azip!((index i, mut d in d_values.outer_iter_mut()) {
            let d_vec = calc_d(&vertices.view(),  &vertex_connectivity, i);
            d[0] = d_vec.x;
            d[1] = d_vec.y;
            d[2] = d_vec.z;
        });

        // Apply second smoothing step (mu)
        par_azip!((index i, mut vertex in vertices.outer_iter_mut(), d in d_values.outer_iter()) {
            let dx: V = NumCast::from(weights[i] * m * d[0]).unwrap_or(vertex[0]);
            let dy: V = NumCast::from(weights[i] * m * d[1]).unwrap_or(vertex[1]);
            let dz: V = NumCast::from(weights[i] * m * d[2]).unwrap_or(vertex[2]);
            vertex[[0]] += dx;
            vertex[[1]] += dy;
            vertex[[2]] += dz;
        });
    }
}

#[pyfunction]
pub fn context_aware_smoothing<'py>(
    vertices: VertexArray<'py>,
    faces: FaceArray<'py>,
    normals: VertexArray<'py>,
    t: f64,
    tmax: f64,
    bmin: f64,
    n_iters: u32,
) -> PyResult<()> {
    match (vertices, faces, normals) {
        // F32 vertices, I64 faces
        (
            VertexArray::F32(mut vertices),
            FaceArray::I64(mut faces),
            VertexArray::F32(mut normals),
        ) => {
            println!("F32 vertices, I64 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        (
            VertexArray::F32(mut vertices),
            FaceArray::I64(mut faces),
            VertexArray::F64(mut normals),
        ) => {
            println!("F32 vertices, I64 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        // F32 vertices, U64 faces
        (
            VertexArray::F32(mut vertices),
            FaceArray::U64(mut faces),
            VertexArray::F32(mut normals),
        ) => {
            println!("F32 vertices, U64 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        (
            VertexArray::F32(mut vertices),
            FaceArray::U64(mut faces),
            VertexArray::F64(mut normals),
        ) => {
            println!("F32 vertices, U64 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        // F32 vertices, I32 faces
        (
            VertexArray::F32(mut vertices),
            FaceArray::I32(mut faces),
            VertexArray::F32(mut normals),
        ) => {
            println!("F32 vertices, I32 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        (
            VertexArray::F32(mut vertices),
            FaceArray::I32(mut faces),
            VertexArray::F64(mut normals),
        ) => {
            println!("F32 vertices, I32 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        // F32 vertices, U32 faces
        (
            VertexArray::F32(mut vertices),
            FaceArray::U32(mut faces),
            VertexArray::F32(mut normals),
        ) => {
            println!("F32 vertices, U32 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        (
            VertexArray::F32(mut vertices),
            FaceArray::U32(mut faces),
            VertexArray::F64(mut normals),
        ) => {
            println!("F32 vertices, U32 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        // F64 vertices, I64 faces
        (
            VertexArray::F64(mut vertices),
            FaceArray::I64(mut faces),
            VertexArray::F32(mut normals),
        ) => {
            println!("F64 vertices, I64 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        (
            VertexArray::F64(mut vertices),
            FaceArray::I64(mut faces),
            VertexArray::F64(mut normals),
        ) => {
            println!("F64 vertices, I64 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        // F64 vertices, U64 faces
        (
            VertexArray::F64(mut vertices),
            FaceArray::U64(mut faces),
            VertexArray::F32(mut normals),
        ) => {
            println!("F64 vertices, U64 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        (
            VertexArray::F64(mut vertices),
            FaceArray::U64(mut faces),
            VertexArray::F64(mut normals),
        ) => {
            println!("F64 vertices, U64 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        // F64 vertices, I32 faces
        (
            VertexArray::F64(mut vertices),
            FaceArray::I32(mut faces),
            VertexArray::F32(mut normals),
        ) => {
            println!("F64 vertices, I32 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        (
            VertexArray::F64(mut vertices),
            FaceArray::I32(mut faces),
            VertexArray::F64(mut normals),
        ) => {
            println!("F64 vertices, I32 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        // F64 vertices, U32 faces
        (
            VertexArray::F64(mut vertices),
            FaceArray::U32(mut faces),
            VertexArray::F32(mut normals),
        ) => {
            println!("F64 vertices, U32 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
        (
            VertexArray::F64(mut vertices),
            FaceArray::U32(mut faces),
            VertexArray::F64(mut normals),
        ) => {
            println!("F64 vertices, U32 faces");
            context_aware_smoothing_internal(
                vertices.as_array_mut(),
                faces.as_array_mut(),
                normals.as_array_mut(),
                t,
                tmax,
                bmin,
                n_iters,
            );
            Ok(())
        }
    }
}
